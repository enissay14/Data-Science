---
title: "Computar Lab Sensitivity Analysis"
author: "Yassine Landa & Samuel Rochette"
date: "December 16, 2015"
output: pdf_document
---

1. Ishigami fonction
```{r}
library(sensitivity)
set.seed(1)

# --------------------------------------
# Ishigami : trace des effets principaux
# --------------------------------------

n <- 1000
X <- data.frame(matrix(runif(3 * n), nrow = n))
X <- X*2*pi - pi
z <- ishigami.fun(X)

mu0 <- mean(z)

t <- seq(from=-pi, to=pi, length=200)

par(mfrow=c(1,3))
for (i in 1:3){
  plot(z - mu0 ~ X[,i], xlab=paste("X", i, sep=""), ylab=expression(f(X)-mu[0]),
       main = paste("Effet principal de la variable X", i, sep=""))
  m.ss <- smooth.spline(X[,i], z-mu0)
  lines(m.ss, lwd=10, col="blue")
}

```
2. Les indices de Sobol de la fonction Ishigami
```{r}
n <- 30; d <- 3

# -- preliminaire : une analyse de sensibilite directe sur ishigami 
# -- ne donne pas de bons resultats (il n'y a pas assez de points)
# pick-freeze
X1 <- data.frame(matrix(runif(d * n, min=-pi, max=pi), nrow = n))
X2 <- data.frame(matrix(runif(d * n, min=-pi, max=pi), nrow = n))
x <- sobol(model = ishigami.fun, X1 = X1, X2 = X2, order = 2, nboot = 100)
print(x)
plot(x)
# -- meme pb avec fast99,
SA.ishigami <- fast99(model = ishigami.fun, factors = 3, n = 90,
                      q = "qunif", q.arg = list(min = -pi, max = pi))
plot(SA.ishigami)
# -- on peut au mieux utiliser la methode de MORRIS
m <- morris(model=ishigami.fun, factors=3, r=7, 
            design = list(type="oat", levels=5, grid.jump=1), 
            binf = -pi, bsup = pi)
print(m)
plot(m)  # qu'en deduire ?

```


*On remarque que c'est X2 qui influe le plus (la plus grande moyenne) .
*X3 n'influe que par son interaction avec X1 .
*X1 a le plus grand $\sigma$ parcequ'elle a un effet principale plus une partie d'intéractions avec X3.

```{r}
# - 1 - construction d'un plan remplissant bien l'espace et sans trop de redondances
library(DiceDesign)
n <- 30; d <- 3

X0 <- lhsDesign(n, d)$design
Xlist <- maximinESE_LHS(X0, T0=0.005*phiP(X0), inner_it=150, J=50, it=2)
X <- Xlist$design
par(mfrow=c(1,1))
pairs(X)
plot(Xlist$critValues,type="l")

X <- X*2*pi-pi
y <- ishigami.fun(X)

# - 2 - construction d'un metamodele de krigeage avec noyau standard (matern 5/2)
library(DiceKriging)
krig.matern52 <- km(formula=~1, design = X, response = y, covtype="matern5_2")
plot(krig.matern52)

# - 3 - analyse de sensibilite du metamodele
kriging.mean <- function(Xnew, m){
    predict(m, Xnew, "UK", se.compute = FALSE, checkNames = FALSE)$mean
}
SA.krig <- fast99(model = kriging.mean , factors = 3, n = 1000, m = krig.matern52,
                      q = "qunif", q.arg = list(min = -pi, max = pi))

```
On compare avec les résultats de 2. A gauche analyse de sensibilité du modèle de Kriging, à droite les indices de Sobol de la fonction Ishigami.
```{r}
# - 4 - comparer avec les indices reels 
par(mfrow=c(1,2))
plot(SA.krig)
plot(SA.ishigami)
```

Avec n = 60
```{r}
n <- 60
X0 <- lhsDesign(n, d)$design
Xlist <- maximinESE_LHS(X0, T0=0.005*phiP(X0), inner_it=150, J=50, it=2)
X <- Xlist$design
X <- X*2*pi-pi
y <- ishigami.fun(X)
krig.matern52.60 <- km(formula=~1, design = X, response = y, covtype="matern5_2")
SA.krig60 <- fast99(model = kriging.mean , factors = 3, n = 1000, m = krig.matern52.60,
                      q = "qunif", q.arg = list(min = -pi, max = pi))
par(mfrow=c(1,2))
plot(SA.krig60)
plot(SA.ishigami)
```

Avec n = 90
```{r}
n <- 90
X0 <- lhsDesign(n, d)$design
Xlist <- maximinESE_LHS(X0, T0=0.005*phiP(X0), inner_it=150, J=50, it=2)
X <- Xlist$design
X <- X*2*pi-pi
y <- ishigami.fun(X)
krig.matern52.90 <- km(formula=~1, design = X, response = y, covtype="matern5_2")
SA.krig90 <- fast99(model = kriging.mean , factors = 3, n = 1000, m = krig.matern52.90,
                      q = "qunif", q.arg = list(min = -pi, max = pi))
par(mfrow=c(1,2))
plot(SA.krig90)
plot(SA.ishigami)
```
```{r}
# - 5 - changer n et recommencer : a partir de quelle valeur les resultats sont satisfaisants ?

# -- remarque : potentiel d'amelioration avec un noyau additif par blocs 
# -- executer l'exemple de 'kmAdditive' du package fanovaGraph

# -- representer graphiquement l'interaction d'ordre 2 (X1,X3) pour ishigami.fun.


## -------------------
## autre fonction
## -------------------
# K (prix d'exercice) : loi uniforme (min=35, max=45), 
# sigma (volatilite)  : loi uniforme (min=0.1, max=0.4), 
# r (taux d'interet)  : loi uniforme (min=0.02, max=0.05) 
vanilla.call <- function(X, S0=40, T=1/3) {
  K <- X[,1]
  sigma <- X[,2]
  r <- X[,3]
  d1 <- (log(S0/K) + (r+sigma^2/2)*T)/(sigma*sqrt(T))
  d2 <- d1 - sigma*sqrt(T)
  S0*pnorm(d1) - K*exp(-r*T)*pnorm(d2)
}
```




