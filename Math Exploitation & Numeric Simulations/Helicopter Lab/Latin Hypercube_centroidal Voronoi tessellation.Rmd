---
title: "TP1"
author: "Landa & Delatte & Wang"
date: "January 12, 2016"
output: pdf_document
---
###Tessellations centroı̈dales de Voronoı̈

macQueen's algorithm
```{r}
generateCVT <- function(npts, dim, nite){
  
  x <- matrix(0, ncol = dim, nrow = npts)
  j <- matrix(1, ncol = npts, nrow = 1)
  #generate random points
  for(i in 1:npts){
    for(k in 1:dim){
      x[i,k] <- runif(1,0,1)
    }
  }
  plot(x,xlim=c(-0.1,1.1),ylim=c(-0.1,1.1))
  for(k in 1:nite){
    
    #generate new point
    w <- matrix(0, ncol = dim, nrow = 1)
    for(i in 1:dim){ w[i] <- runif(1,0,1)}
    
    #the closest point
    idx <- which.min(apply(x, 1, function(x){ sqrt(sum((x-w)^2))}))
    z <- x[idx,]
    
    #update point
    x[idx,] <- ( j[idx]*z + w ) / (j[idx] + 1)
    j[idx] <- j[idx] + 1
     
  }
  x
}
x <- generateCVT(5,2,10000)
points(x,col="red")
```


###Hypercube Latins
Pour générer un hypercube latin on génére une permutation de la taille du nombre de points passé à la fonction *generateLHS* et ce autant de fois qu'on a de dimensions
```{r}
generateLHS <- function(npts, dim){
  x <- matrix(0,ncol = dim, nrow = npts)
  for(i in 1:npts){x[i,1] <- runif(1,0,1)}
  for(i in 2:dim){x[,i]<-sample(x[,1])}
  x 
}
LHS <- generateLHS(40,4)
```

###Critères
```{r}
evalMinDist<-function(x){
  npts=nrow(x)
  y <- as.matrix(dist(x))
  tmp<-as.matrix(dist(x))
  diag(tmp) <- 1
  x1 <- which(tmp == min(tmp), arr.ind=TRUE)[1,1]
  x2 <- which(tmp == min(tmp), arr.ind=TRUE)[1,2]
  d<-min(y[y>0])
  return(list(minDist=d,allDist = y,criticPts=c(x1,x2)))
}

#Exemple on CVT
critere <- evalMinDist(x)
critere$minDist
h <- hist(critere$allDist)
sd(h$density)

#Exemple on LHS
critere <- evalMinDist(LHS)
critere$minDist
h <- hist(critere$allDist)
sd(h$density)
```
###Hypercubes latins optimisés
```{r}
###########################
#   recherche aléatoire   #
###########################

n<-10000
min<-0
for (i in 1:n){
    result<-generateLHS(40,4)
    eval<-evalMinDist(result)
    if(eval$minDist>min){
      min<-eval$minDist
      result_final<-result
    }
}

essay1<-result_final
evalMinDist(essay1)$minDist
hist(evalMinDist(essay1)$allDist[,1])
hist(evalMinDist(essay1)$allDist[,2])
hist(evalMinDist(essay1)$allDist[,3])
hist(evalMinDist(essay1)$allDist[,4])
write.csv2(essay1)
```

```{r}
###########################
#      recuit simulé      #
###########################

recuitSIM <- function(npts,dim,nite,method,steps){
 
  
  #LHS initial
  if(method=="CVT"){x <- generateCVT(npts,dim,nite)}
  if(method=="LHS"){x <- generateLHS(npts,dim)}
  score <- evalMinDist(x)$minDist
  conv <- matrix(score,ncol = steps, nrow = 1)
  
  T <- matrix(1,ncol = steps, nrow = 1)
  for(i in 1:steps){
    #pts critiques
    criticPts <- evalMinDist(x)$criticPts
    
    #echange
    col <- sample(1:dim,1)
    row <- sample(1:npts,1)
    tmp <- x[criticPts[1],col]
    x[criticPts[1],col] <- x[row,col]
    x[row,col] <- tmp  
    
    
    if(evalMinDist(x)$minDist > score){
      score <- evalMinDist(x)$minDist
    }
    else{
      pal <- runif(1,0,1)
      T[i] <- T[1]/log(i+1)
      p <- exp( score - evalMinDist(x)$minDist ) / T[i]
      if(p > pal){score <- evalMinDist(x)$minDist}
    }
    conv[i] <- score
  
  }
  
  return(list(x = x,conv = conv))
}

X <- recuitSIM(40,4,1000,"LHS",10000)
evalMinDist(X$x)$minDist
hist(evalMinDist(X$x)$allDist[,1])
hist(evalMinDist(X$x)$allDist[,2])
hist(evalMinDist(X$x)$allDist[,3])
hist(evalMinDist(X$x)$allDist[,4])
plot(1:10000,X$conv,type="l")

```



